{"componentChunkName":"component---src-templates-post-template-tsx","path":"/2022-06-23-[item3]-private 생성자나 열거타입으로 싱글턴임을 보장하라/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<blockquote>\n<p><strong>private 생성자나 열거타입으로 싱글턴임을 보장하라</strong></p>\n</blockquote>\n<p>저자는 싱글턴을 만들 때 private 생성자나 열거타입(enum)으로 만들길 권장하고 있습니다. 그 이유에 대해 알아보겠습니다.</p>\n<blockquote>\n<p><strong>싱글턴</strong>: 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다.</p>\n</blockquote>\n<p>싱글턴을 만드는 방식엔 총 3가지가 있습니다.</p>\n<ol>\n<li><code class=\"language-text\">public static final</code> 필드 방식의 싱글턴</li>\n<li>정적 팩터리 메서드를 사용하는 방식의 싱글턴</li>\n<li><strong>열거 타입 방식의 싱글턴</strong></li>\n</ol>\n<p>결론부터 말씀드리면, 저자가 생각하는 가장 좋은 싱글턴 패턴은 <strong>열거 타입</strong>을 사용하는 것입니다. 위의 싱글턴을 만드는 방식에 대해 하나하나 알아보면서 각각 어떤 장단점이 있는 지 알아보겠습니다.</p>\n<h2>public static final 필드 방식의 싱글턴</h2>\n<script src=\"https://gist.github.com/gusah009/1f7e3efcc5f36fc28483f8afb7c35509.js\"></script>\n<p><code class=\"language-text\">private</code> 생성자는 <code class=\"language-text\">MyDate.INSTANCE</code>를 생성할 때 단 한번만 호출되고, <code class=\"language-text\">public</code>이나 <code class=\"language-text\">protected</code> 생성자가 없기 때문에 항상 시스템엔 <code class=\"language-text\">MyDate</code>의 객체가 하나임이 보장됩니다. 하지만 <code class=\"language-text\">setAccessible</code>이란 리플렉션 API를 사용하면 <code class=\"language-text\">private</code> 생성자를 호출할 수 있는데, 이 내용에 대해선 뒤에 배웁니다.</p>\n<h3>장점</h3>\n<p>해당 클래스가 싱글턴임이 API에 명백히 드러난다는 장점이 있습니다. public static 필드가 final이니 절대 다른 객체를 참조할 수 없음을 한 눈에 확인할 수 있습니다. 또 간결함이 가장 큰 장점입니다.</p>\n<h2>정적 팩터리 메서드 방식의 싱글턴</h2>\n<script src=\"https://gist.github.com/gusah009/f15488726c7055f44b64a15b22aa36e8.js\"></script>\n<p><code class=\"language-text\">INSTANCE</code>가 <code class=\"language-text\">private</code>이기 때문에 이를 호출하는 방식은 <code class=\"language-text\">getInstance()</code>밖에 없습니다. 위와 무슨 차이가 있는거지? 하실 수 있기 때문에 아래에서 정적 팩터리 메서드 방식의 장점을 바로 살펴보겠습니다.</p>\n<h3>장점</h3>\n<p>위 방식의 장점은 마음이 바뀌면 API를 바꾸지 않고도 싱글턴이 아니게끔 변경할 수 있습니다. 클라이언트 코드에선 <code class=\"language-text\">getInstance()</code>로 instance를 불러오기 때문에 <strong>이게 싱글턴인지, 아니면 다른 어떤 객체인 지 알지 않아도 됩니다.</strong></p>\n<p>두 번째 장점은 원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다는 점입니다. 제네릭 싱글턴 팩터리에 대해선 이후 <code class=\"language-text\">[item30]</code>에서 배웁니다.</p>\n<p>마지막 장점은 정적 팩터리 메서드 참조를 공급자(supplier)로 사용 할 수 있다는 점입니다. <code class=\"language-text\">Supplier&lt;INSTANCE></code>로도 쓸 수 있다는 장점이 있습니다.</p>\n<h3>위의 두 방식의 단점</h3>\n<p>하지만 위의 두 방식 모두 단점이 존재합니다. 바로 직렬화할 때의 문제인데, 보통 직렬화를 구현하기 위해 우리는 <code class=\"language-text\">Serializable</code> 인터페이스를 구현해 사용합니다. 하지만 이 방식만으로 객체를 직렬화하고, <strong>역직렬화해서 객체를 사용하게 되면 새로운 인스턴스가 만들어 집니다.</strong> 즉, 싱글턴이 보장되지 않는다는 것입니다. 이런 가짜 인스턴스를 막기 위한 방법이 존재하는데, 이는 이후 <code class=\"language-text\">[item89]</code>에서 살펴보겠습니다.</p>\n<h2>열거 타입 방식의 싱글턴</h2>\n<p>결국 저자가 권유하는 싱글턴 생성 방식은 열거타입(enum)입니다.</p>\n<script src=\"https://gist.github.com/gusah009/cf50a9e2ae0ac18e94878b508448be7e.js\"></script>\n<p>아래와 같이 특정 <code class=\"language-text\">Instance</code>를 싱글턴 형식으로 사용할 수 있으며, 앞서 봤던 단점들인 아주 복잡한 직렬화 상황이나 리플렉션 공격에서도 제2의 인스턴스가 생기는 일을 완벽히 막아줍니다. 저자는 <strong>부자연스러워 보일 순 있지만 대부분의 상황에서 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법</strong>이라고 말하고 있습니다.</p>\n<h3>단점</h3>\n<p>단, 만드려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다는 단점이 있습니다.</p>\n<h3>Ref.</h3>\n<p><a href=\"https://junha.tistory.com/25\" target=\"_blank\" rel=\"nofollow\">https://junha.tistory.com/25</a></p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","frontmatter":{"title":"[item3] private 생성자나 열거타입으로 싱글턴임을 보장하라","summary":"저자는 싱글턴을 만들 때 private 생성자나 열거타입(enum)으로 만들길 권장하고 있습니다. 그 이유에 대해 알아보겠습니다.","date":"2022.06.23.","categories":["effective_java"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABF0lEQVQoz5VSXUvDQBDM//9Dgi8qWouIlFoRxIci1fiRtiGmba67N7OySdqGSisOw3HHZXbnJpuUZRlCABD/CVVNqqoSESOJaEdBcm+feE9Qq1XMM5r56TC8RQcJYiNeIh2DhqP4JQbcvhkmz/iawAwx7vi3OEYFECrenmKathozJ7njvpgbsap7zjMMe+ifcHiFLMX0Hd9zgPDiEXVK2HLXWdUbumdFOuZDn6M+7844uMDg3Dm8xOMNR9d4GuC+h09/YEcMtFF3y4ugWmJRuKlixuwNHy/OYt7aFpEQgoioqoo41/WqolG1TkRBX0k1c4I+JE0G/p222n1sbzrVRcTfXCyWr/l6tvIa8cCQNuE2m81P9HH8AfEtvWYqDufzAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/566e2033ea33b3ea3c36622f93317786/70f15/pathfinder_loss.png","srcSet":"/static/566e2033ea33b3ea3c36622f93317786/5738e/pathfinder_loss.png 211w,\n/static/566e2033ea33b3ea3c36622f93317786/16394/pathfinder_loss.png 422w,\n/static/566e2033ea33b3ea3c36622f93317786/70f15/pathfinder_loss.png 843w","sizes":"(min-width: 843px) 843px, 100vw"},"sources":[{"srcSet":"/static/566e2033ea33b3ea3c36622f93317786/824e6/pathfinder_loss.webp 211w,\n/static/566e2033ea33b3ea3c36622f93317786/1a33f/pathfinder_loss.webp 422w,\n/static/566e2033ea33b3ea3c36622f93317786/b762a/pathfinder_loss.webp 843w","type":"image/webp","sizes":"(min-width: 843px) 843px, 100vw"}]},"width":843,"height":518}},"publicURL":"/static/566e2033ea33b3ea3c36622f93317786/pathfinder_loss.png"}}}}]}},"pageContext":{"slug":"/2022-06-23-[item3]-private 생성자나 열거타입으로 싱글턴임을 보장하라/"}},"staticQueryHashes":["2518467932","429584967"]}